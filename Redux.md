# ðŸ“˜ React Redux with Redux Toolkit (RTK) - Complete Guide

## 1. Introduction to Redux
**Redux** is a state management library that provides **Global State** for React applications. It allows state to be accessible from any component in the tree, regardless of hierarchy.

### The Three Main Concepts
1.  **Store:**
    *   The single source of truth.
    *   Contains the entire global state of the application.
    *   Usually made up of multiple "slices" (e.g., Counter slice, User slice).
2.  **Actions:**
    *   Instructions sent to Redux to tell it *what* to do.
    *   **Structure:**
        *   `type` (Required, String): The name of the action (e.g., `"increment"`).
        *   `payload` (Optional): Data needed to perform the action (e.g., the amount to add).
3.  **Reducers:**
    *   Functions that take the current state and an action, then return a new state based on the action type.
    *   **Immutability Rule:** You must **never** mutate the state directly in standard Redux. You must create a copy, modify the copy, and replace the original.
    *   *Note:* Redux Toolkit handles immutability automatically (explained in section 4).

---

## 2. Setting up the Store
We use `configureStore` from Redux Toolkit to set up the store easily.

**File:** `state/store.ts`

```typescript
import { configureStore } from "@reduxjs/toolkit";
// We will import the reducer later once created
// import counterReducer from './counter/counterSlice';

export const store = configureStore({
  reducer: {
    // Reducers will go here
    // counter: counterReducer,
  },
});

// TypeScript Helper Types
// Exporting these makes it easier to work with useSelector and useDispatch
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

---

## 3. Connecting Redux to React
To make the store accessible to the React app, we use the `Provider` component.

**File:** `main.tsx` (or `App.tsx`)

```tsx
import { Provider } from "react-redux";
import { store } from "./state/store";

// Wrap the main App component with Provider
ReactDOM.createRoot(document.getElementById('root')!).render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

---

## 4. Creating a Slice (State, Reducers, Actions)
A "Slice" contains the state, reducers, and actions for a specific feature. We use `createSlice` to minimize boilerplate.

**File:** `state/counter/counterSlice.ts`

### Step A: Define State and Initial State
```typescript
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

interface CounterState {
  value: number;
}

const initialState: CounterState = {
  value: 0,
};
```

### Step B: Create the Slice
**Crucial Concept:** Inside `createSlice`, we can write code that *looks* like it is mutating the state (e.g., `state.value += 1`).
*   **Why?** Redux Toolkit uses a library called **Immer** behind the scenes.
*   Immer detects changes, creates a copy, applies changes to the copy, and returns the new state safely.

```typescript
const counterSlice = createSlice({
  name: "counter",
  initialState,
  reducers: {
    // Simple Action (No payload)
    increment: (state) => {
      state.value += 1; // "Mutating" syntax allowed here thanks to Immer
    },
    decrement: (state) => {
      state.value -= 1;
    },
    // Action with Payload
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },
});

// Export Actions (Auto-generated by createSlice)
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// Export Reducer to connect to the store
export default counterSlice.reducer;
```

### Step C: Update the Store
Go back to `state/store.ts` and add the reducer.

```typescript
import counterReducer from "./counter/counterSlice";

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

---

## 5. Using Redux in Components
We use hooks from `react-redux` to interact with the store.

**File:** `components/Counter.tsx`

1.  **`useSelector`**: To read data from the store.
2.  **`useDispatch`**: To send actions to the store.

```tsx
import { useDispatch, useSelector } from "react-redux";
import { RootState, AppDispatch } from "../state/store";
import { increment, decrement, incrementByAmount } from "../state/counter/counterSlice";

const Counter = () => {
  // Select state using the RootState type for intellisense
  const count = useSelector((state: RootState) => state.counter.value);
  
  // Get the dispatch function (Typed with AppDispatch for async thunks later)
  const dispatch = useDispatch<AppDispatch>(); 

  return (
    <div>
      <h2>{count}</h2>
      <div>
        {/* Simple Actions */}
        <button onClick={() => dispatch(increment())}>Increment</button>
        <button onClick={() => dispatch(decrement())}>Decrement</button>
        
        {/* Action with Payload */}
        <button onClick={() => dispatch(incrementByAmount(10))}>
            Increment by 10
        </button>
      </div>
    </div>
  );
};

export default Counter;
```

---

## 6. Asynchronous Actions (Async Thunks)
For async operations (API calls, timers), standard reducers won't work. We use `createAsyncThunk`.

### Defining the Thunk
Add this to `counterSlice.ts` (usually above `createSlice`).

```typescript
import { createAsyncThunk } from "@reduxjs/toolkit";

// createAsyncThunk(Action Name, Async Function)
export const incrementAsync = createAsyncThunk(
  "counter/incrementAsync",
  async (amount: number) => {
    // Simulate async work (e.g., API fetch)
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return amount; // The return value becomes the 'fulfilled' payload
  }
);
```

### Handling Thunks in ExtraReducers
Async thunks have three lifecycles: `pending`, `fulfilled`, and `rejected`. These must be handled in the `extraReducers` property of `createSlice`, using a `builder`.

```typescript
const counterSlice = createSlice({
  name: "counter",
  initialState,
  reducers: { 
    // ... synchronous reducers (increment, decrement) 
  },
  extraReducers: (builder) => {
    builder
      // Handle Pending State
      .addCase(incrementAsync.pending, () => {
        console.log("incrementAsync.pending");
      })
      // Handle Fulfilled State (Data received)
      .addCase(incrementAsync.fulfilled, (state, action: PayloadAction<number>) => {
        state.value += action.payload; // Payload comes from the return of the thunk
      });
  },
});
```

### Using the Async Action
In the component:
```tsx
import { incrementAsync } from "../state/counter/counterSlice";

// ... inside component
<button onClick={() => dispatch(incrementAsync(10))}>Increment Async</button>
```
*Note: The UI will log "pending", wait 1 second, then update the state.*

---

## 7. Redux DevTools
A browser extension invaluable for debugging.

1.  **Installation:** Install "Redux DevTools" for your browser.
2.  **Connection:** RTK connects to it automatically.
3.  **Features shown in the video:**
    *   **Action Log:** See every action fired (`counter/increment`, `counter/incrementAsync/fulfilled`).
    *   **Diffing:** See exactly how the state changed (e.g., `value: 0 -> 10`).
    *   **Time Travel:** You can click "Jump" on previous actions to revert the app state to that specific moment in time.
    *   **Async Tracking:** Shows the flow of Async Thunks from `pending` -> `fulfilled`.

## Summary of Workflow
1.  **Setup:** Create `store` using `configureStore` and wrap app in `Provider`.
2.  **Define:** Create a slice using `createSlice` (define state, reducers, and actions).
3.  **Read:** Use `useSelector` in components to access state.
4.  **Write:** Use `useDispatch` to fire actions imported from the slice.
5.  **Async:** Use `createAsyncThunk` and `extraReducers` for side effects.
